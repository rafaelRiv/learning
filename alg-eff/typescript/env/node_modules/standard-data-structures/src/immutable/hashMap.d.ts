import { ICollection } from '../internals/iCollection';
import { Option } from './option';
/**
 * An immutable HashMap
 */
export declare class HashMap<K, V> implements ICollection<V> {
    private readonly dict;
    /**
     * Refer [[ICollection.asArray]]
     */
    readonly asArray: V[];
    /**
     * Refer [[ICollection.isEmpty]]
     */
    readonly isEmpty: boolean;
    /**
     * Creates a new instance of [[HashMap]]
     */
    static of<K, V>(entries?: ReadonlyArray<readonly [K, V]>): HashMap<K, V>;
    private constructor();
    /**
     * Deletes the provided key from the HashMap
     */
    delete(k: K): HashMap<K, V>;
    /**
     * Refer [[ICollection.filter]]
     */
    filter(fn: (kv: V) => boolean): HashMap<K, V>;
    /**
     * Refer [[ICollection.fold]]
     * Use `HasMap.fold0` to fold with keys.
     */
    fold<S>(S: S, fn: (kv: V, S: S) => S): S;
    /**
     * Folds a [[HasMap]] into a value, by calling the function on each key value pair.
     */
    fold0<S>(S: S, fn: (V: V, K: K, S: S) => S): S;
    /**
     * Returns value for the provided key
     */
    get(k: K): Option<V>;
    /**
     * Returns true if the value exists in the HashMap
     */
    has(k: K): boolean;
    /**
     * Refer [[ICollection.map]]
     */
    map<B>(ab: (V: V) => B): HashMap<K, B>;
    /**
     * Sets a key value pair and returns a new [[HashMap]].
     */
    set(k: K, v: V): HashMap<K, V>;
}
