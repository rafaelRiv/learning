"use strict";
/**
 * Created by tushar on 07/09/19
 */
Object.defineProperty(exports, "__esModule", { value: true });
const option_1 = require("./option");
/**
 * A data structure that represents Success/Failure & optional types
 * @typeparam L1 Represents Left case that can be used to depict failures.
 * @typeparam R1 Represents Right case that can be used to depict success.
 */
class Either {
    /**
     * Converts an [[Either]] to an [[Option]]
     */
    get asOption() {
        return this.fold(option_1.Option.none(), L => option_1.Option.none(), R => option_1.Option.some(R));
    }
    /**
     * Creates an [[Either]] from [[Option]]
     */
    static fromOption(option) {
        return option.asEither;
    }
    /**
     * Returns true if the either is of [[Left]] type.
     */
    static isLeft(either) {
        return either instanceof Left;
    }
    /**
     * Returns true if the either is of [[Right]] type.
     */
    static isRight(either) {
        return either instanceof Right;
    }
    /**
     * Creates an object of [[Left]] type.
     */
    static left(left) {
        return new Left(left);
    }
    /**
     * Creates an object of [[Right]] type.
     */
    static right(right) {
        return new Right(right);
    }
    /**
     * Creates a new [[Either]] type from a function that could fail with an error.
     */
    static try(cb) {
        try {
            return Either.right(cb());
        }
        catch (e) {
            return Either.left(e);
        }
    }
    /**
     * It uses the left function to chain over object of [[Left]] type
     * and the right function to chain over an object of [[Right]] type.
     */
    biMap(LL, RR) {
        return this.mapL(LL).mapR(RR);
    }
    /**
     * Alias for [[Either.chainR]]
     */
    chain(ab) {
        return this.chainR(ab);
    }
    /**
     * Sequentially converts a [[Left]] type to another [[Left]] type.
     */
    chainL(ab) {
        return this.biChain(ab, Either.right);
    }
    /**
     * Sequentially converts a [[Right]] type to another [[Right]] type.
     */
    chainR(ab) {
        return this.biChain(Either.left, ab);
    }
    /**
     * Alias for [[Either.mapR]]
     */
    map(ab) {
        return this.mapR(ab);
    }
    /**
     * Transforms the left value
     */
    mapL(ab) {
        return this.chainL(r => Either.left(ab(r)));
    }
    /**
     * Transforms the right value
     */
    mapR(ab) {
        return this.chainR(r => Either.right(ab(r)));
    }
}
exports.Either = Either;
/**
 * Data structure that represents a left value
 */
class Left extends Either {
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Refer [[Either.biChain]]
     */
    biChain(LL, RR) {
        return LL(this.value);
    }
    /**
     * Refer [[Either.fold]]
     */
    fold(S, LL, RR) {
        return LL(this.value, S);
    }
    /**
     * Refer [[Either.getLeftOrElse]]
     */
    getLeftOrElse(left) {
        return this.value;
    }
    /**
     * Refer [[Either.getRightOrElse]]
     */
    getRightOrElse(right) {
        return right;
    }
    /**
     * Refer [[Either.reduce]]
     */
    reduce(LL, RR) {
        return LL(this.value);
    }
}
exports.Left = Left;
/**
 * Data structure that represents a right value
 */
class Right extends Either {
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Refer [[Either.biChain]]
     */
    biChain(LL, RR) {
        return RR(this.value);
    }
    /**
     * Refer [[Either.fold]]
     */
    fold(S, LL, RR) {
        return RR(this.value, S);
    }
    /**
     * Refer [[Either.getLeftOrElse]]
     */
    getLeftOrElse(left) {
        return left;
    }
    /**
     * Refer [[Either.getRightOrElse]]
     */
    getRightOrElse(right) {
        return this.value;
    }
    /**
     * Refer [[Either.reduce]]
     */
    reduce(LL, RR) {
        return RR(this.value);
    }
}
exports.Right = Right;
