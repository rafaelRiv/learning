import { ICancellable } from 'ts-scheduler';
import { Exit } from '../main/Exit';
import { QIO } from '../main/QIO';
import { FiberRuntime } from '../runtimes/FiberRuntime';
import { CBExit } from './CBExit';
export declare abstract class Fiber<A, E> {
    static unsafeExecuteWith<A, E>(io: QIO<A, E>, runtime: FiberRuntime, cb?: CBExit<A, E>): ICancellable;
    abstract abort: QIO<void>;
    abstract await: QIO<Exit<A, E>>;
    readonly id: number;
    abstract runtime: FiberRuntime;
    get join(): QIO<A, E>;
}
export declare class FiberContext<A, E> extends Fiber<A, E> implements ICancellable {
    readonly runtime: FiberRuntime;
    static unsafeExecuteWith<A, E>(io: QIO<A, E>, runtime: FiberRuntime, cb?: CBExit<A, E>): FiberContext<A, E>;
    private readonly cancellationList;
    private node?;
    private readonly observers;
    private result?;
    private readonly stackA;
    private readonly stackEnv;
    private status;
    private readonly yieldStrategy;
    private constructor();
    get abort(): QIO<void>;
    get await(): QIO<Exit<A, E>>;
    cancel(): void;
    unsafeObserve(cb: CBExit<A, E>): ICancellable;
    private completeFiber;
    private dispatchResult;
    private pauseAndUnsafeEvaluate;
    private unsafeEvaluate;
}
