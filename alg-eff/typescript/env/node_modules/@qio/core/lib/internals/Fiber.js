"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FiberContext = exports.Fiber = void 0;
const debug_1 = require("debug");
const standard_data_structures_1 = require("standard-data-structures");
const Exit_1 = require("../main/Exit");
const Instructions_1 = require("../main/Instructions");
const QIO_1 = require("../main/QIO");
const CancellationList_1 = require("./CancellationList");
const IDGenerator_1 = require("./IDGenerator");
const YieldStrategy_1 = require("./YieldStrategy");
const D = debug_1.debug('qio:fiber');
class InvalidInstruction extends Error {
    constructor(ins) {
        super(`${Instructions_1.Tag[ins.tag]}`);
    }
}
var FiberStatus;
(function (FiberStatus) {
    FiberStatus[FiberStatus["PENDING"] = 0] = "PENDING";
    FiberStatus[FiberStatus["COMPLETED"] = 1] = "COMPLETED";
    FiberStatus[FiberStatus["CANCELLED"] = 2] = "CANCELLED";
})(FiberStatus || (FiberStatus = {}));
class StupidCancel {
    cancel() { }
}
class RemoveNode {
    constructor(node, list) {
        this.node = node;
        this.list = list;
    }
    cancel() {
        this.list.remove(this.node);
    }
}
const FIBER_ID = new IDGenerator_1.IDGenerator();
class Fiber {
    constructor() {
        this.id = FIBER_ID.create();
    }
    static unsafeExecuteWith(io, runtime, cb) {
        return FiberContext.unsafeExecuteWith(io, runtime, cb);
    }
    get join() {
        return this.await.chain(QIO_1.QIO.fromExit);
    }
}
exports.Fiber = Fiber;
class FiberContext extends Fiber {
    constructor(instruction, runtime) {
        super();
        this.runtime = runtime;
        this.cancellationList = new CancellationList_1.CancellationList();
        this.observers = standard_data_structures_1.DoublyLinkedList.of();
        this.stackA = new Array();
        this.stackEnv = new Array();
        this.status = FiberStatus.PENDING;
        this.yieldStrategy = YieldStrategy_1.YieldStrategy.create(this.runtime.scheduler, this.runtime.config);
        D(this.id, 'this.constructor()');
        this.stackA.push(instruction);
        this.pauseAndUnsafeEvaluate();
    }
    static unsafeExecuteWith(io, runtime, cb) {
        const context = new FiberContext(io.asInstruction, runtime);
        if (cb !== undefined) {
            context.unsafeObserve(cb);
        }
        return context;
    }
    get abort() {
        return QIO_1.QIO.lift(() => this.cancel());
    }
    get await() {
        D(this.id, 'this.await()');
        return QIO_1.QIO.uninterruptible((cb) => {
            this.unsafeObserve(cb);
            return this;
        });
    }
    cancel() {
        D(this.id, 'this.cancel()');
        D(this.id, 'this.observers.length == ', this.observers.length);
        this.status = FiberStatus.CANCELLED;
        D(this.id, 'this.status ==', FiberStatus[this.status]);
        this.cancellationList.cancel();
        this.dispatchResult(Exit_1.Exit.cancel());
    }
    unsafeObserve(cb) {
        D(this.id, 'this.unsafeObserve()');
        if (this.status === FiberStatus.CANCELLED) {
            cb(Exit_1.Exit.cancel());
            return new StupidCancel();
        }
        if (this.status === FiberStatus.COMPLETED && this.result !== undefined) {
            cb(this.result);
            return new StupidCancel();
        }
        const node = this.observers.add(cb);
        D(this.id, 'this.status ==', FiberStatus[this.status]);
        D(this.id, 'this.observers.add()');
        D(this.id, 'this.observers.length == ', this.observers.length);
        D(this.id, 'this.observers.length == ', this.observers.length);
        const c = new RemoveNode(node, this.observers);
        D(this.id, 'this.observer.remove()');
        D(this.id, 'this.observers.length == ', this.observers.length);
        return c;
    }
    completeFiber(result) {
        D('%O dispatchResult() // %O', this.id, result);
        this.status = FiberStatus.COMPLETED;
        this.result = result;
        this.dispatchResult(result);
    }
    dispatchResult(result) {
        while (this.observers.length > 0) {
            const element = this.observers.shift();
            if (standard_data_structures_1.Option.isSome(element)) {
                element.value(result);
            }
        }
    }
    pauseAndUnsafeEvaluate(data) {
        D(this.id, 'start()');
        this.node = this.cancellationList.push(this.yieldStrategy.insert(this.unsafeEvaluate.bind(this), data));
    }
    unsafeEvaluate(ddd) {
        D(this.id, 'unsafeEvaluate()');
        if (this.node !== undefined) {
            this.cancellationList.remove(this.node);
            this.node = undefined;
        }
        let data = ddd;
        while (true) {
            if (this.yieldStrategy.canYield()) {
                return this.pauseAndUnsafeEvaluate(data);
            }
            try {
                const j = this.stackA.pop();
                if (j === undefined) {
                    return this.completeFiber(Exit_1.Exit.succeed(data));
                }
                switch (j.tag) {
                    case Instructions_1.Tag.Constant:
                        data = j.i0;
                        break;
                    case Instructions_1.Tag.Call:
                        this.stackA.push(j.i0(...j.i1));
                        break;
                    case Instructions_1.Tag.Runtime:
                        data = this.runtime;
                        break;
                    case Instructions_1.Tag.Reject:
                        while (this.stackA.length > 0 &&
                            this.stackA[this.stackA.length - 1].tag !== Instructions_1.Tag.Capture) {
                            this.stackA.pop();
                        }
                        const cause = j.i0;
                        const handler = this.stackA.pop();
                        if (handler !== undefined && handler.tag === Instructions_1.Tag.Capture) {
                            this.stackA.push(handler.i0(cause));
                        }
                        else {
                            return this.completeFiber(Exit_1.Exit.fail(cause));
                        }
                        break;
                    case Instructions_1.Tag.Try:
                        data = j.i0(data);
                        break;
                    case Instructions_1.Tag.TryM:
                        this.stackA.push(j.i0(data));
                        break;
                    case Instructions_1.Tag.Map:
                        this.stackA.push(QIO_1.QIO.resume(j.i1).asInstruction);
                        this.stackA.push(j.i0);
                        break;
                    case Instructions_1.Tag.Capture:
                        break;
                    case Instructions_1.Tag.Chain:
                        this.stackA.push(QIO_1.QIO.resumeM(j.i1).asInstruction);
                        this.stackA.push(j.i0);
                        break;
                    case Instructions_1.Tag.Catch:
                        this.stackA.push(QIO_1.QIO.capture(j.i1).asInstruction);
                        this.stackA.push(j.i0);
                        break;
                    case Instructions_1.Tag.Never:
                        return;
                    case Instructions_1.Tag.Fork:
                        const nContext = new FiberContext(j.i0, j.i1);
                        this.cancellationList.push(nContext);
                        data = nContext;
                        break;
                    case Instructions_1.Tag.Provide:
                        this.stackA.push(QIO_1.QIO.resume((i) => {
                            this.stackEnv.pop();
                            return i;
                        }).asInstruction);
                        this.stackA.push(j.i0);
                        this.stackEnv.push(j.i1);
                        break;
                    case Instructions_1.Tag.Access:
                        const env = this.stackEnv[this.stackEnv.length - 1];
                        data = j.i0(env);
                        break;
                    case Instructions_1.Tag.Async:
                        const id = this.cancellationList.push(j.i0((val) => {
                            this.cancellationList.remove(id);
                            this.stackA.push(QIO_1.QIO.resolve(val).asInstruction);
                            this.unsafeEvaluate();
                        }, (err) => {
                            this.cancellationList.remove(id);
                            this.stackA.push(QIO_1.QIO.reject(err).asInstruction);
                            this.unsafeEvaluate();
                        }));
                        return;
                    default:
                        this.stackA.push(QIO_1.QIO.reject(new InvalidInstruction(j)).asInstruction);
                }
            }
            catch (e) {
                this.stackA.push(QIO_1.QIO.reject(e).asInstruction);
            }
        }
    }
}
exports.FiberContext = FiberContext;
