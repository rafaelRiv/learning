import { Either } from 'standard-data-structures';
import { ICancellable } from 'ts-scheduler';
import { CB } from '../internals/CB';
import { Fiber } from '../internals/Fiber';
import { FiberConfig } from '../internals/FiberConfig';
import { Exit } from '../main/Exit';
import { IRuntime } from '../runtimes/IRuntime';
import { Instruction, Tag } from './Instructions';
export declare class QIO<A1 = unknown, E1 = never, R1 = unknown> {
    readonly tag: Tag;
    readonly i0?: unknown;
    readonly i1?: unknown;
    static access<R, A>(cb: (R: R) => A): QIO<A, never, R>;
    static accessA<A, E, R>(fn: (A: CB<A>, E: CB<E>, R: R) => void): QIO<A, E, R>;
    static accessM<A1, E1, R1, R2>(cb: (R: R1) => QIO<A1, E1, R2>): QIO<A1, E1, R1 & R2>;
    static accessP<A1, R1>(cb: (R: R1) => Promise<A1>): QIO<A1, Error, R1>;
    static ap<A1, E1, R1, A2>(qio: QIO<(a: A1) => A2, E1, R1>, input: A1): QIO<A2, E1, R1>;
    static call<A1, E1, R1, T extends unknown[]>(fn: (...t: T) => QIO<A1, E1, R1>, ...args: T): QIO<A1, E1, R1>;
    static capture<A1, E1, A2>(cb: (A: A1) => Instruction): QIO<A2, E1>;
    static catch<A1, E1, R1, A2, E2, R2>(fa: QIO<A1, E1, R1>, aFe: (e: E1) => QIO<A2, E2, R2>): QIO<A2, E2, R1 & R2>;
    static chain<A1, E1, R1, A2, E2, R2>(fa: QIO<A1, E1, R1>, aFb: (a: A1) => QIO<A2, E2, R2>): QIO<A2, E1 | E2, R1 & R2>;
    static encase<A = never, E = never, T extends unknown[] = unknown[]>(cb: (...t: T) => A): (...t: T) => QIO<A, E>;
    static encaseM<A = never, E = never, R = unknown, T extends unknown[] = unknown[]>(cb: (...t: T) => QIO<A, E, R>): (...t: T) => QIO<A, E, R>;
    static encaseP<A, T extends unknown[]>(cb: (...t: T) => Promise<A>): (...t: T) => QIO<A, Error>;
    static env<R1 = never>(): QIO<R1, never, R1>;
    static flatten<A1, E1, R1, A2, E2, R2>(qio: QIO<QIO<A2, E2, R2>, E1, R1>): QIO<A2, E1 | E2, R1 & R2>;
    static fork<A1, E1>(io: QIO<A1, E1>, runtime: IRuntime): QIO<Fiber<A1, E1>>;
    static fromEither<A, E>(exit: Either<E, A>): QIO<A, E>;
    static fromExit<A, E>(exit: Exit<A, E>): QIO<A, E>;
    static if<A1, E1, R1, A2, E2, R2>(cond: boolean, left: QIO<A1, E1, R1>, right: QIO<A2, E2, R2>): QIO<A1 | A2, E1 | E2, R1 & R2>;
    static if0<T extends unknown[]>(...args: T): <A1, E1, R1, A2, E2, R2>(cond: (...args: T) => boolean, left: (...args: T) => QIO<A1, E1, R1>, right: (...args: T) => QIO<A2, E2, R2>) => QIO<A1 | A2, E1 | E2, R1 & R2>;
    static interruptible<A1 = never, E1 = never>(cb: (res: CB<A1>, rej: CB<E1>) => ICancellable): QIO<A1, E1>;
    static lazy<T extends unknown[], A1, E1, R1>(fn: (...T: T) => QIO<A1, E1, R1>): (...T: T) => QIO<A1, E1, R1>;
    static lift<A1 = unknown, E1 = never>(cb: () => A1): QIO<A1, E1>;
    static map<A1, E1, R1, A2>(fa: QIO<A1, E1, R1>, ab: (a: A1) => A2): QIO<A2, E1, R1>;
    static never(): QIO<never>;
    static par<A1, E1, R1>(ios: Array<QIO<A1, E1, R1>>): QIO<A1[], E1, R1>;
    static parN<A1, E1, R1>(N: number, ios: Array<QIO<A1, E1, R1>>): QIO<A1[], E1, R1>;
    static pipeEnv<T extends unknown[], A1, E1, R1>(fn: (..._: T) => QIO<A1, E1, R1>, R: R1): (..._: T) => QIO<A1, E1>;
    static reject<E1>(error: E1): QIO<never, E1>;
    static resolve<A1>(value: A1): QIO<A1>;
    static resume<A1, A2>(cb: (A: A1) => A2): QIO<A2>;
    static resumeM<A1, E1, A2>(cb: (A: A1) => Instruction): QIO<A2, E1>;
    static runtime(): QIO<IRuntime>;
    static seq<A1, E1, R1>(ios: Array<QIO<A1, E1, R1>>): QIO<A1[], E1, R1>;
    static timeout<A>(value: A, duration: number): QIO<A>;
    static try<A>(cb: () => A): QIO<A, Error>;
    static tryM<A1, E1, R1>(qio: () => QIO<A1, E1, R1>): QIO<A1, E1, R1>;
    static tryP<A>(cb: () => Promise<A>): QIO<A, Error>;
    static uninterruptible<A1 = never, E1 = never>(fn: (res: CB<A1>, rej: CB<E1>) => unknown): QIO<A1, E1>;
    static void(): QIO<void>;
    readonly $R1?: (r: R1) => void;
    constructor(tag: Tag, i0?: unknown, i1?: unknown);
    get asEither(): QIO<Either<E1, A1>, never, R1>;
    get asInstruction(): Instruction;
    get env(): QIO<R1, never, R1>;
    get once(): QIO<QIO<A1, E1>, never, R1>;
    get void(): QIO<void, E1, R1>;
    addEnv<R2>(): QIO<A1, E1, R1 & R2>;
    and<A2, E2, R2>(aFb: QIO<A2, E2, R2>): QIO<A2, E1 | E2, R1 & R2>;
    bracket<E2, R2>(release: (A1: A1) => QIO<unknown, E2, R2>): <A3, E3, R3>(usage: (A1: A1) => QIO<A3, E3, R3>) => QIO<A3, E1 | E2 | E3, R1 & R2 & R3>;
    bracket_<E2, R2>(release: QIO<unknown, E2, R2>): <A3, E3, R3>(usage: (A1: A1) => QIO<A3, E3, R3>) => QIO<A3, E1 | E2 | E3, R1 & R2 & R3>;
    catch<A2, E2, R2>(aFb: (e: E1) => QIO<A2, E2, R2>): QIO<A1 | A2, E2, R1 & R2>;
    chain<A2, E2, R2>(aFb: (a: A1) => QIO<A2, E2, R2>): QIO<A2, E1 | E2, R1 & R2>;
    const<A2>(a: A2): QIO<A2, E1, R1>;
    delay(duration: number): QIO<A1, E1, R1>;
    do<E2, R2>(io: QIO<unknown, E2, R2>): QIO<A1, E1 | E2, R1 & R2>;
    encase<A2 = unknown, E2 = never>(fn: (A1: A1) => A2): QIO<A2, E1 | E2, R1>;
    encaseM<A2 = unknown, E2 = never, R2 = unknown>(fn: (A1: A1) => QIO<A2, E2, R2>): QIO<A2, E1 | E2, R1 & R2>;
    fork(config?: FiberConfig): QIO<Fiber<A1, E1>, never, R1>;
    forkWith(runtime: IRuntime): QIO<Fiber<A1, E1>, never, R1>;
    map<A2>(ab: (a: A1) => A2): QIO<A2, E1, R1>;
    par<A2, E2, R2>(that: QIO<A2, E2, R2>): QIO<[A1, A2], E1 | E2, R1 & R2>;
    provide(r1: R1): QIO<A1, E1>;
    provideM<E2, R2>(io: QIO<R1, E2, R2>): QIO<A1, E1 | E2, R2>;
    provideSome<R0>(fn: (R2: R0) => R1): QIO<A1, E1, R0>;
    provideSomeM<E2, R0>(qio: QIO<R1, E2, R0>): QIO<A1, E1 | E2, R0>;
    race<A2, E2, R2>(that: QIO<A2, E2, R2>): QIO<A1 | A2, E1 | E2, R1 & R2>;
    raceWith<A2, E2, R2, A3, E3, A4, E4>(that: QIO<A2, E2, R2>, cb1: (exit: Exit<A1, E1>, fiber: Fiber<A2, E2>) => QIO<A3, E3>, cb2: (exit: Exit<A2, E2>, fiber: Fiber<A1, E1>) => QIO<A4, E4>): QIO<A3 | A4, E3 | E4, R1 & R2>;
    rejectWith<E2>(error: E2): QIO<A1, E1 | E2, R1>;
    tap(fn: (A: A1) => void): QIO<A1, E1, R1>;
    tapM<E2, R2>(io: (A1: A1) => QIO<unknown, E2, R2>): QIO<A1, E1 | E2, R1 & R2>;
    zip<A2, E2, R2>(that: QIO<A2, E2, R2>): QIO<[A1, A2], E1 | E2, R1 & R2>;
    zipWith<A2, E2, R2, C>(that: QIO<A2, E2, R2>, c: (a1: A1, a2: A2) => C): QIO<C, E1 | E2, R1 & R2>;
    zipWithM<A2, E2, R2, A3, E3, R3>(that: QIO<A2, E2, R2>, c: (a1: A1, a2: A2) => QIO<A3, E3, R3>): QIO<A3, E1 | E2 | E3, R1 & R2 & R3>;
    zipWithPar<A2, E2, R2, C>(that: QIO<A2, E2, R2>, c: (e1: A1, e2: A2) => C): QIO<C, E1 | E2, R1 & R2>;
}
