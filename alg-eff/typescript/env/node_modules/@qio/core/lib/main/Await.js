"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Await = void 0;
const debug_1 = require("debug");
const standard_data_structures_1 = require("standard-data-structures");
const IDGenerator_1 = require("../internals/IDGenerator");
const QIO_1 = require("./QIO");
var AwaitStatus;
(function (AwaitStatus) {
    AwaitStatus[AwaitStatus["PENDING"] = 0] = "PENDING";
    AwaitStatus[AwaitStatus["STARTED"] = 1] = "STARTED";
    AwaitStatus[AwaitStatus["COMPLETED"] = 2] = "COMPLETED";
})(AwaitStatus || (AwaitStatus = {}));
const AWAIT_ID = new IDGenerator_1.IDGenerator();
const D = (id, scope, ...t) => debug_1.debug('qio:await')(id, scope, ...t);
class Await {
    constructor() {
        this.id = AWAIT_ID.create();
        this.flag = AwaitStatus.PENDING;
        this.Q = standard_data_structures_1.DoublyLinkedList.of();
        this.result = standard_data_structures_1.Option.none();
    }
    static of() {
        return QIO_1.QIO.lift(() => {
            const awt = new Await();
            D(awt.id, 'this.constructor()');
            return awt;
        });
    }
    get get() {
        return QIO_1.QIO.tryM(() => this.result
            .map((S) => S.reduce(QIO_1.QIO.reject, (XX) => QIO_1.QIO.resolve(XX)))
            .getOrElse(this.wait));
    }
    get isSet() {
        return QIO_1.QIO.lift(() => this.flag === AwaitStatus.COMPLETED);
    }
    get wait() {
        return QIO_1.QIO.interruptible((res, rej) => {
            const id = this.Q.add([res, rej]);
            D(this.id, 'add wait');
            D(this.id, 'this.Q.length', this.Q.length);
            return {
                cancel: () => {
                    this.Q.remove(id);
                    D(this.id, 'remove wait');
                    D(this.id, 'this.Q.length', this.Q.length);
                },
            };
        });
    }
    set(io) {
        return QIO_1.QIO.tryM(() => {
            D(this.id, 'set', 'status', AwaitStatus[this.flag]);
            if (this.flag > AwaitStatus.PENDING) {
                return QIO_1.QIO.resolve(false);
            }
            this.flag = AwaitStatus.STARTED;
            D(this.id, 'set', 'status', AwaitStatus[this.flag]);
            return io.asEither.encase((either) => {
                this.flag = AwaitStatus.COMPLETED;
                D(this.id, 'set', 'status', AwaitStatus[this.flag]);
                this.result = standard_data_structures_1.Option.some(either);
                while (this.Q.length > 0) {
                    const node = this.Q.shift();
                    if (standard_data_structures_1.Option.isSome(node)) {
                        either.reduce(node.value[1], node.value[0]);
                    }
                }
                return true;
            });
        });
    }
    setTo(a) {
        return this.set(QIO_1.QIO.resolve(a));
    }
}
exports.Await = Await;
