"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.QIO = void 0;
const prelude_1 = require("@qio/prelude");
const debug_1 = require("debug");
const standard_data_structures_1 = require("standard-data-structures");
const Exit_1 = require("../main/Exit");
const Await_1 = require("./Await");
const Instructions_1 = require("./Instructions");
const D = (scope, f, ...t) => debug_1.debug('qio:core:' + scope)(f, ...t);
class QIO {
    constructor(tag, i0, i1) {
        this.tag = tag;
        this.i0 = i0;
        this.i1 = i1;
    }
    static access(cb) {
        return new QIO(Instructions_1.Tag.Access, cb);
    }
    static accessA(fn) {
        return QIO.accessM((RR) => QIO.uninterruptible((AA, EE) => fn(AA, EE, RR)));
    }
    static accessM(cb) {
        return QIO.flatten(QIO.access(cb));
    }
    static accessP(cb) {
        return QIO.env().chain(QIO.encaseP(cb));
    }
    static ap(qio, input) {
        return qio.map((ab) => ab(input));
    }
    static call(fn, ...args) {
        return new QIO(Instructions_1.Tag.Call, fn, args);
    }
    static capture(cb) {
        return new QIO(Instructions_1.Tag.Capture, cb);
    }
    static catch(fa, aFe) {
        return new QIO(Instructions_1.Tag.Catch, fa, aFe);
    }
    static chain(fa, aFb) {
        if (fa.tag === Instructions_1.Tag.Constant) {
            return aFb(fa.i0);
        }
        return new QIO(Instructions_1.Tag.Chain, fa, aFb);
    }
    static encase(cb) {
        return (...t) => QIO.lift(() => cb(...t));
    }
    static encaseM(cb) {
        return (...t) => QIO.tryM(() => cb(...t));
    }
    static encaseP(cb) {
        return (...t) => QIO.runtime().chain((RTM) => QIO.interruptible((res, rej) => RTM.scheduler.asap(() => {
            void cb(...t)
                .then(res)
                .catch(rej);
        })));
    }
    static env() {
        return QIO.access(prelude_1.Id);
    }
    static flatten(qio) {
        return qio.chain(prelude_1.Id);
    }
    static fork(io, runtime) {
        return new QIO(Instructions_1.Tag.Fork, io, runtime);
    }
    static fromEither(exit) {
        return exit.fold(QIO.never(), QIO.reject, QIO.resolve);
    }
    static fromExit(exit) {
        return Exit_1.Exit.fold(exit)(QIO.never(), QIO.resolve, QIO.reject);
    }
    static if(cond, left, right) {
        return (cond ? left : right);
    }
    static if0(...args) {
        return (cond, left, right) => cond(...args) ? left(...args) : right(...args);
    }
    static interruptible(cb) {
        return new QIO(Instructions_1.Tag.Async, cb);
    }
    static lazy(fn) {
        return (...T0) => QIO.call(fn, ...T0);
    }
    static lift(cb) {
        return QIO.resume(cb);
    }
    static map(fa, ab) {
        if (fa.tag === Instructions_1.Tag.Constant) {
            return QIO.resolve(ab(fa.i0));
        }
        return new QIO(Instructions_1.Tag.Map, fa, ab);
    }
    static never() {
        return new QIO(Instructions_1.Tag.Never, undefined);
    }
    static par(ios) {
        return ios
            .reduce((a, b) => a.zipWithPar(b, (acc, value) => {
            D('par acc %O', acc, value);
            D('par value %O', value);
            return acc.prepend(value);
        }), QIO.env().and(QIO.lift(() => standard_data_structures_1.List.empty())))
            .map((_) => _.asArray.reverse());
    }
    static parN(N, ios) {
        const itar = (list) => QIO.if(list.length === 0, QIO.resolve([]), QIO.par(list.slice(0, N)).chain((l1) => itar(list.slice(N, list.length)).map((l2) => l1.concat(l2))));
        return itar(ios);
    }
    static pipeEnv(fn, R) {
        return (...T0) => fn(...T0).provide(R);
    }
    static reject(error) {
        return new QIO(Instructions_1.Tag.Reject, error);
    }
    static resolve(value) {
        return new QIO(Instructions_1.Tag.Constant, value);
    }
    static resume(cb) {
        return new QIO(Instructions_1.Tag.Try, cb);
    }
    static resumeM(cb) {
        return new QIO(Instructions_1.Tag.TryM, cb);
    }
    static runtime() {
        return new QIO(Instructions_1.Tag.Runtime);
    }
    static seq(ios) {
        return ios
            .reduce((fList, f) => fList.chain((list) => f.map((value) => list.prepend(value))), QIO.lift(() => standard_data_structures_1.List.empty()).addEnv())
            .map((_) => _.asArray);
    }
    static timeout(value, duration) {
        return QIO.runtime().chain((RTM) => QIO.interruptible((res) => RTM.scheduler.delay(res, duration, value)));
    }
    static try(cb) {
        return QIO.lift(cb);
    }
    static tryM(qio) {
        return QIO.flatten(QIO.lift(qio));
    }
    static tryP(cb) {
        return QIO.encaseP(cb)();
    }
    static uninterruptible(fn) {
        return QIO.runtime().chain((RTM) => QIO.interruptible((res, rej) => RTM.scheduler.asap(() => {
            try {
                fn(res, rej);
            }
            catch (e) {
                rej(e);
            }
        })));
    }
    static void() {
        return QIO.resolve(void 0);
    }
    get asEither() {
        return this.map(standard_data_structures_1.Either.right).catch((_) => QIO.resolve(standard_data_structures_1.Either.left(_)));
    }
    get asInstruction() {
        return this;
    }
    get env() {
        return QIO.access(prelude_1.Id);
    }
    get once() {
        return this.env.chain((env) => Await_1.Await.of().map((AWT) => AWT.set(this.provide(env)).and(AWT.get)));
    }
    get void() {
        return this.const(undefined);
    }
    addEnv() {
        return QIO.env().and(this);
    }
    and(aFb) {
        return this.chain(() => aFb);
    }
    bracket(release) {
        return (usage) => this.chain((a1) => usage(a1)
            .fork()
            .chain((F) => F.await.and(release(a1)).chain((_) => F.join)));
    }
    bracket_(release) {
        return this.bracket(() => release);
    }
    catch(aFb) {
        return QIO.catch(this, aFb);
    }
    chain(aFb) {
        return QIO.chain(this, aFb);
    }
    const(a) {
        return this.and(QIO.resolve(a));
    }
    delay(duration) {
        return QIO.timeout(this, duration).chain(prelude_1.Id);
    }
    do(io) {
        return this.chain((_) => io.const(_));
    }
    encase(fn) {
        return this.chain(QIO.encase(fn));
    }
    encaseM(fn) {
        return this.chain(QIO.encaseM(fn));
    }
    fork(config) {
        return QIO.env().zipWithM(QIO.runtime(), (ENV, RTM) => QIO.fork(this.provide(ENV), RTM.configure(config === undefined ? RTM.config : config)));
    }
    forkWith(runtime) {
        return QIO.env().chain((ENV) => QIO.fork(this.provide(ENV), runtime));
    }
    map(ab) {
        return QIO.map(this, ab);
    }
    par(that) {
        return this.zipWithPar(that, (a, b) => [a, b]);
    }
    provide(r1) {
        return new QIO(Instructions_1.Tag.Provide, this, r1);
    }
    provideM(io) {
        return io.chain((ENV) => this.provide(ENV));
    }
    provideSome(fn) {
        return QIO.accessM((r0) => this.provide(fn(r0)));
    }
    provideSomeM(qio) {
        return qio.chain((_) => this.provide(_));
    }
    race(that) {
        return this.raceWith(that, (E, F) => F.abort.const(E), (E, F) => F.abort.const(E)).chain((E) => QIO.fromExit(E));
    }
    raceWith(that, cb1, cb2) {
        return Await_1.Await.of().chain((done) => {
            D('raceWith', 'await id:', done.id);
            return this.fork().zipWithM(that.fork(), (L, R) => {
                D('raceWith', 'fiber L.id', L.id, '& fiber R.id', R.id);
                const resume1 = L.await.chain((exit) => {
                    D('raceWith', 'L cb');
                    return done.set(cb1(exit, R)).const(true);
                });
                const resume2 = R.await.chain((exit) => {
                    D('raceWith', 'R cb');
                    return done.set(cb2(exit, L)).const(true);
                });
                return resume1.fork().and(resume2.fork()).and(done.get);
            });
        });
    }
    rejectWith(error) {
        return this.and(QIO.reject(error));
    }
    tap(fn) {
        return this.tapM(QIO.encase(fn));
    }
    tapM(io) {
        return this.chain((_) => io(_).const(_));
    }
    zip(that) {
        return this.zipWith(that, (a, b) => [a, b]);
    }
    zipWith(that, c) {
        return this.chain((a1) => that.map((a2) => c(a1, a2)));
    }
    zipWithM(that, c) {
        return QIO.flatten(this.zipWith(that, c));
    }
    zipWithPar(that, c) {
        return this.raceWith(that, (E, F) => Exit_1.Exit.fold(E)(QIO.never(), (value) => F.join.map((_) => c(value, _)), (cause) => F.abort.and(QIO.reject(cause))), (E, F) => Exit_1.Exit.fold(E)(QIO.never(), (value) => F.join.map((_) => c(_, value)), (cause) => F.abort.and(QIO.reject(cause))));
    }
}
exports.QIO = QIO;
