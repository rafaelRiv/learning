"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Queue = void 0;
const debug_1 = require("debug");
const standard_data_structures_1 = require("standard-data-structures");
const IDGenerator_1 = require("../internals/IDGenerator");
const Await_1 = require("./Await");
const QIO_1 = require("./QIO");
const QUEUE_ID = new IDGenerator_1.IDGenerator();
const D = (scope, f, ...t) => debug_1.debug('qio:queue')(scope, f, ...t);
const consume = (T) => {
    const R = new Array();
    while (T.length !== 0) {
        const item = T.shift();
        if (standard_data_structures_1.Option.isSome(item)) {
            R.push(item.value);
        }
    }
    return R;
};
class Queue {
    constructor(capacity) {
        this.capacity = capacity;
        this.id = QUEUE_ID.create();
        this.O = standard_data_structures_1.DoublyLinkedList.of();
        this.Q = standard_data_structures_1.DoublyLinkedList.of();
        this.T = standard_data_structures_1.DoublyLinkedList.of();
    }
    static bounded(capacity) {
        return QIO_1.QIO.lift(() => new Queue(capacity));
    }
    static unbounded() {
        return Queue.bounded(Number.MAX_SAFE_INTEGER);
    }
    get asArray() {
        return QIO_1.QIO.lift(() => this.Q.asArray);
    }
    get length() {
        return QIO_1.QIO.lift(() => this.Q.length);
    }
    get take() {
        return QIO_1.QIO.tryM(() => {
            D('%i this.take() %O', this.id, this.stat);
            const sz = this.Q.shift();
            if (standard_data_structures_1.Option.isSome(sz)) {
                return this.resolvePendingOffers().const(sz.value);
            }
            return Await_1.Await.of().chain(QIO_1.QIO.encaseM((awt) => {
                this.T.add(awt);
                return awt.get;
            }));
        }).do(this.resolvePendingOffers());
    }
    get waitForSpace() {
        return Await_1.Await.of().encaseM((AWT) => {
            this.O.add(AWT);
            return AWT.get;
        });
    }
    get stat() {
        return {
            pOffers: this.O.length,
            pTakes: this.T.length,
            queue: this.Q.length,
        };
    }
    offer(a) {
        return QIO_1.QIO.tryM(() => {
            D('%i this.offer(%O) %O', this.id, a, this.stat);
            if (this.Q.length === this.capacity) {
                return this.waitForSpace.and(this.offer(a));
            }
            this.Q.add(a);
            return this.resolvePendingTakes();
        });
    }
    offerAll(...a) {
        return QIO_1.QIO.seq(a.map((_) => this.offer(_))).void;
    }
    takeN(n) {
        const itar = (i, list) => QIO_1.QIO.if0()(() => i === n, () => QIO_1.QIO.resolve(list), () => this.take.chain((_) => itar(i + 1, list.prepend(_))));
        return itar(0, standard_data_structures_1.List.empty()).map((_) => _.asArray.reverse());
    }
    resolvePendingOffers() {
        return QIO_1.QIO.seq(consume(this.O).map((_) => _.setTo(true))).void;
    }
    resolvePendingTakes() {
        if (this.T.length > 0) {
            const aa = this.Q.shift();
            if (standard_data_structures_1.Option.isSome(aa)) {
                return QIO_1.QIO.seq(consume(this.T).map((_) => _.setTo(aa.value))).void;
            }
        }
        return QIO_1.QIO.void();
    }
}
exports.Queue = Queue;
