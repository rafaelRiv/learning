export declare abstract class Chunk<A> implements Iterable<A> {
    static createN<A>(arr: A[], n: number): Chunk<A>;
    static empty<A>(): Chunk<A>;
    static from<A>(arr: A[]): Chunk<A>;
    static isEmpty<A>(C: Chunk<A>): C is Empty;
    static of<A>(A: A): Chunk<A>;
    abstract asArray: A[];
    abstract readonly length: number;
    abstract [Symbol.iterator](): Iterator<A>;
    chain<B>(fn: (A: A) => Chunk<B>): Chunk<B>;
    concat(that: Chunk<A>): Chunk<A>;
    abstract filter(fn: (A: A) => boolean): Chunk<A>;
    abstract fold<S>(S: S, fn: (A: A, S: S) => S): S;
    abstract map<B>(fn: (A: A) => B): Chunk<B>;
}
declare class Empty extends Chunk<never> {
    readonly length = 0;
    get asArray(): never[];
    [Symbol.iterator](): Iterator<never>;
    filter(fn: (A: never) => boolean): Chunk<never>;
    fold<S>(S: S, fn: (A: never, S: S) => S): S;
    map<B>(fn: (A: never) => B): Chunk<B>;
}
export {};
