"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Chunk = void 0;
const split = (min, max, count, expected) => {
    for (let i = 0; i < count; i++) {
        if (i * min + (count - i) * max === expected) {
            return i;
        }
    }
    return count;
};
const createChunkCapacity = (count, minSize, maxSize, distribution) => {
    const chunks = new Array();
    for (let i = 0; i < count; i++) {
        chunks.push(i < distribution ? minSize : maxSize);
    }
    return chunks;
};
const createChunks = (arr, chunkCount) => {
    const itemCount = arr.length;
    const chunks = new Array([]);
    const minChunkSize = Math.floor(arr.length / chunkCount);
    const maxChunkSize = minChunkSize + 1;
    const distribution = split(minChunkSize, maxChunkSize, chunkCount, itemCount);
    const chunkCapacity = createChunkCapacity(chunkCount, minChunkSize, maxChunkSize, distribution);
    let selectedChunk = 0;
    for (let i = 0; i < itemCount; i++) {
        if (chunks[selectedChunk].length === chunkCapacity[selectedChunk]) {
            selectedChunk++;
            chunks.push([]);
        }
        chunks[selectedChunk].push(arr[i]);
    }
    return chunks;
};
class Chunk {
    static createN(arr, n) {
        return createChunks(arr, n)
            .map((_) => Chunk.from(_))
            .reduce((a, c) => a.concat(c), Chunk.empty());
    }
    static empty() {
        return new Empty();
    }
    static from(arr) {
        return new ArrayC(arr);
    }
    static isEmpty(C) {
        return C instanceof Empty;
    }
    static of(A) {
        return new Value(A);
    }
    chain(fn) {
        return this.fold(Chunk.empty(), (AA, SS) => SS.concat(fn(AA)));
    }
    concat(that) {
        if (Chunk.isEmpty(that)) {
            return this;
        }
        if (Chunk.isEmpty(this)) {
            return that;
        }
        return new Concat(this, that);
    }
}
exports.Chunk = Chunk;
class Concat extends Chunk {
    constructor(L, R) {
        super();
        this.L = L;
        this.R = R;
        this.length = this.L.length + this.R.length;
    }
    get asArray() {
        return this.L.asArray.concat(this.R.asArray);
    }
    *[Symbol.iterator]() {
        for (const i of this.L) {
            yield i;
        }
        for (const i of this.R) {
            yield i;
        }
    }
    filter(fn) {
        return new Concat(this.L.filter(fn), this.R.filter(fn));
    }
    fold(S, fn) {
        return this.R.fold(this.L.fold(S, fn), fn);
    }
    map(fn) {
        return new Concat(this.L.map(fn), this.R.map(fn));
    }
}
class ArrayC extends Chunk {
    constructor(array) {
        super();
        this.array = array;
        this.length = this.array.length;
    }
    get asArray() {
        return this.array;
    }
    [Symbol.iterator]() {
        return this.array[Symbol.iterator]();
    }
    filter(fn) {
        return new ArrayC(this.array.filter(fn));
    }
    fold(S, fn) {
        let value = S;
        for (let i = 0; i < this.array.length; i++) {
            value = fn(this.array[i], value);
        }
        return S;
    }
    map(fn) {
        return new ArrayC(this.array.map(fn));
    }
}
class Empty extends Chunk {
    constructor() {
        super(...arguments);
        this.length = 0;
    }
    get asArray() {
        return [];
    }
    *[Symbol.iterator]() { }
    filter(fn) {
        return this;
    }
    fold(S, fn) {
        return S;
    }
    map(fn) {
        return this;
    }
}
class Value extends Chunk {
    constructor(value) {
        super();
        this.value = value;
        this.length = 1;
    }
    get asArray() {
        return [this.value];
    }
    *[Symbol.iterator]() {
        yield this.value;
    }
    filter(fn) {
        return fn(this.value) ? new Value(this.value) : new Empty();
    }
    fold(S, fn) {
        return fn(this.value, S);
    }
    map(fn) {
        return new Value(fn(this.value));
    }
}
