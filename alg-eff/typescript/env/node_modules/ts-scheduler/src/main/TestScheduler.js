"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const checked_exceptions_1 = require("checked-exceptions");
const standard_data_structures_1 = require("standard-data-structures");
const Bailout_1 = require("../internals/Bailout");
/**
 * Thrown when run() is called twice during the same loop.
 * @ignore
 */
exports.ForbiddenNestedRun = checked_exceptions_1.check('ForbiddenNestedRun', () => 'calling scheduler.run() inside a scheduled job is forbidden');
const DEFAULT_SCHEDULER_OPTIONS = {
    bailout: 100
};
/**
 * TestScheduler tries to mimic the javascript event loop and provides a low level API
 * to manage the queue. You add add/remove new callbacks also run and then pause
 * the execution for sometime.
 */
class TestScheduler {
    constructor(options) {
        this.nextTick = 1;
        this.time = 0;
        this.Q = new Map();
        this.isRunning = false;
        this.options = Object.assign(Object.assign({}, DEFAULT_SCHEDULER_OPTIONS), options);
    }
    asap(fn, ...args) {
        return this.insert(this.nextTick, { fn, args });
    }
    delay(fn, duration, ...args) {
        return this.insert(this.now() + duration, { fn, args });
    }
    now() {
        return this.time;
    }
    run() {
        if (!this.isRunning) {
            this.isRunning = true;
            const checker = Bailout_1.Bailout(this.options.bailout);
            while (this.hasJob() && checker()) {
                this.tick();
            }
            this.isRunning = false;
        }
        else {
            throw new exports.ForbiddenNestedRun();
        }
    }
    runTo(n) {
        const checker = Bailout_1.Bailout(this.options.bailout);
        while (this.now() < n && checker()) {
            this.tick();
        }
    }
    runBy(n) {
        this.runTo(this.now() + n);
    }
    hasJob() {
        for (const _ of this.Q) {
            if (_[1].length > 0) {
                return true;
            }
        }
        return false;
    }
    tick() {
        this.time++;
        this.flush();
        this.nextTick = this.time + 1;
    }
    getList(seq) {
        const ll = this.Q.get(seq);
        if (ll) {
            return ll;
        }
        const linkedList = standard_data_structures_1.DoublyLinkedList.of();
        this.Q.set(seq, linkedList);
        return linkedList;
    }
    insert(time, job) {
        const list = this.getList(time);
        const id = list.add(job);
        return {
            cancel: () => {
                list.remove(id);
            }
        };
    }
    flush() {
        const checker = Bailout_1.Bailout(this.options.bailout);
        const tick = this.time;
        const qElement = this.Q.get(tick);
        while (qElement && qElement.length > 0 && checker()) {
            const headElement = qElement.shift();
            if (standard_data_structures_1.Option.isSome(headElement)) {
                headElement.value.fn(...headElement.value.args);
            }
        }
        this.Q.delete(tick);
    }
}
exports.TestScheduler = TestScheduler;
